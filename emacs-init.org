#+TITLE: Emacs Configuration
#+AUTHOR: David Jung
#+EMAIL: sungwonida@gmail.com

#+NAME: Note
#+BEGIN_SRC emacs-lisp
  ;;; ------------------------------------------
  ;;; Do not edit this file. It was tangled from
  ;;; an org file.
  ;;; ------------------------------------------
#+END_SRC

* Emacs Configuration in an Org file
  I've declared Emacs config bankruptcy for the new year, and it couldn't have
  come at a better time. All at once there are a bunch of new tools for
  Emacs configuration: =use-package= (and =req-package=, used here) and
  =bind-key= simplify a lot of the annoying bits. Dependency management was hard
  before Emacs 24, but with these new tools we can vastly simplify the process.
  We even get a simpler keybinding mechanism in the bargain.

* Package Management with Pallet
  [[https://github.com/rdallasgray/pallet][Pallet]] is a wonderful little tool built on [[https://github.com/cask/cask][Cask]], a dependency management tool
  for Emacs packages. Pallet adds automatic updating of the =Caskfile= when
  packages are installed and deleted.

** Installing Cask
   Just run this command in your terminal of choice:

   #+NAME: Cask Installation
   #+BEGIN_SRC sh
     $ curl -fsSkL https://raw.github.com/cask/cask/master/go | python
   #+END_SRC

   then add =~/.cask/bin= to your =PATH= so that you can use =cask=.

** Creating a Caskfile
   For now, we just need a minimal =Cask= to get Pallet set up. Mine looks
   like this:

   #+NAME: Cask
   #+BEGIN_SRC emacs-lisp :tangle no
     (source melpa)
     (source gnu)

     (depends-on "pallet")
     (depends-on "req-package")
   #+END_SRC

   Then run the following command in your =.emacs.d= directory to set up Pallet:

   #+NAME: Cask Initialization
   #+BEGIN_SRC sh
     cask install
   #+END_SRC

** Initialize Cask
   Finally, we add the following lines to our init file:

   #+BEGIN_SRC emacs-lisp :tangle no
     (require 'cask "~/.cask/cask.el")
     (cask-initialize)
   #+END_SRC

* Dependency Management with =req-package=
  [[https://github.com/edvorg/req-package][req-package]] is a wrapper on top of [[https://github.com/jwiegley/use-package][use-package]], a package dependency
  management tool. The documentation for =use-package= is immensely helpful for
  figuring out how to describe package dependencies and settings. =req-package=
  adds the =:require= keyword which allows us to define dependencies between
  related packages.
** Initialize =req-package=
   With the preceding process complete, we just need to add the following line
   to our init file to begin using =req-package=:

   #+BEGIN_SRC emacs-lisp
     (require 'req-package)
     (setq custom-file "~/.emacs.d/custom.el")
     (load custom-file)
   #+END_SRC

** Local Packages
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'load-path "~/.emacs.d/packages")
     (let ((default-directory "~/.emacs.d/packages"))
       (normal-top-level-add-subdirs-to-load-path))
   #+END_SRC

* Keybindings with =bind-key=
  There are a number of ways to bind keys in Emacs, but I find
  =bind-key=, bundled with =use-package=, easier to work with and,
  more importantly, easier to read. =bind-key= takes a key sequence, a
  command, and an optional keymap.  =bind-key*= overrides any minor
  mode which sets the keybinding. =unbind-key= takes a key sequence
  and a keymap and removes that binding. Invoking
  =describe-personal-keybindings= prints a summary of your keybindings
  through =bind-key= and any overrides or conflicts. This is really
  the killer convenience of using =bind-key=.

* Helm
  Coming from Vim, I was very used to the fuzzy matching of CtrlP. [[http://www.emacswiki.org/emacs/InteractivelyDoThings][Ido]] is a
  popular choice when one wishes to add this functionality to Emacs since it is
  built in and there is a fairly significant ecosystem built around it. I used
  Ido for a while, but after experimenting with [[https://github.com/emacs-helm/helm][Helm]], I've decided to migrate.
  Think of Helm as CtrlP for every minibuffer. From describing functions and
  variables to interacting with =org=, Helm covers just about anything.

** =helm=
   Helm offers a command called =helm-mini= that opens a =helm= buffer populated
   with recent files and currently open buffers. I want Helm everywhere, so
   instead we'll activate =helm-mode= and work from there.

   #+BEGIN_SRC emacs-lisp
     (req-package helm-core)
     (req-package helm
       :config
       (helm-mode 1)
       (bind-key* "M-x" 'helm-M-x)
       (bind-key* "C-x C-f" 'helm-find-files))
     (req-package helm-config
       :require popwin
       (progn
         (setq helm-ff-auto-update-initial-value)
         (setq popwin:special-display-config
               (append helm-popwin
                       popwin:special-display-config))))
     (req-package helm-ls-git
       :config
       (define-key global-map (kbd "C-c h f") 'helm-ls-git-ls))
     (req-package helm-git-grep
       :config
       (define-key global-map (kbd "C-c h g") 'helm-git-grep-at-point))
     (req-package helm-gtags)
     (defun my-helm-mode-hook ()
       (helm-gtags-mode 1)
       (define-key helm-gtags-mode-map (kbd "C-c g a") 'helm-gtags-tags-in-this-function)
       (define-key helm-gtags-mode-map (kbd "M-s") 'helm-gtags-select)
       (define-key helm-gtags-mode-map (kbd "M-.") 'helm-gtags-dwim)
       (define-key helm-gtags-mode-map (kbd "M-,") 'helm-gtags-find-rtag) ;helm-gtags-pop-stack
       (define-key helm-gtags-mode-map (kbd "C-c C-,") 'helm-gtags-previous-history)
       (define-key helm-gtags-mode-map (kbd "C-c C-.") 'helm-gtags-next-history)
       (define-key helm-gtags-mode-map (kbd "C-c g u") 'helm-gtags-update-tags))
     (add-hook 'dired-mode-hook 'helm-gtags-mode)
     (add-hook 'eshell-mode-hook 'helm-gtags-mode)
     (add-hook 'c-mode-common-hook 'my-helm-mode-hook)
     (add-hook 'c-mode-hook 'my-helm-mode-hook)
     (add-hook 'c++-mode-hook 'my-helm-mode-hook)

     ;(global-set-key (kbd "C-c h") 'helm-command-prefix)
     (global-unset-key (kbd "C-x c"))
     (define-key global-map (kbd "\C-x \C-b") 'helm-buffers-list)
     (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action)

     (setq helm-split-window-in-side-p               t
           helm-move-to-line-cycle-in-source         t
           helm-ff-search-library-in-sexp            t
           helm-scroll-amount                        8
           helm-ff-file-name-history-use-recentf     t
           helm-gtags-ignore-case                    t
           helm-gtags-auto-update                    t
           helm-gtags-use-input-at-cursor            t
           helm-gtags-pulse-at-cursor                t
           helm-gtags-prefix-key                     "\C-cg"
           helm-gtags-suggested-key-mapping          t
           )
   #+END_SRC

** =popwin=
   The one annoying thing about =helm= is that the window it opens to show
   results is kinda huge. I use [[https://github.com/m2ym/popwin-el][popwin]] to limit the height of most of the
   Helm buffers.

   #+BEGIN_SRC emacs-lisp
     (req-package popwin
       (popwin-mode 1)
       (setq helm-popwin
             '(("*Helm Find Files*" :height 10)
               ("^\*helm.+\*$" :regexp t :height 10))))
   #+END_SRC

* Org
  #+BEGIN_SRC emacs-lisp
     (req-package org
       :config
       (progn
         (add-hook 'org-mode-hook
                   '(lambda ()
                      (setq mode-name " ꙮ ")))
         (bind-key* "C-c c" 'org-capture)
         (bind-key* "C-c l" 'org-store-link)
         (bind-key* "C-c a" 'org-agenda)
         (bind-key* "C-c b" 'org-iswitch))
       :init
       (progn
         (setq org-image-actual-width nil)
         (setq org-html-inline-image-rules
         '(("file" . "\\.\\(jpeg\\|jpg\\|png\\|gif\\|svg\\|bmp\\)\\'")
         ("http" . "\\.\\(jpeg\\|jpg\\|png\\|gif\\|svg\\|bmp\\)\\'")
         ("https" . "\\.\\(jpeg\\|jpg\\|png\\|gif\\|svg\\|bmp\\)\\'")))))
  #+END_SRC

* UI
  I'm pretty picky about how I want my editor to look, so there's a fair bit of
  configuration that goes here.

** Modeline
   Powerline is very popular in Vim (and with Evil users), but I much prefer
   [[https://github.com/Bruce-Connor/smart-mode-line][smart-mode-line]]. It's compatible with just about anything you can imagine,
   and it's easy to set up.


*** =nyan-mode=
    [[https://github.com/TeMPOraL/nyan-mode][nyan-mode]] is a goofy way to display one's location in a file.

    #+BEGIN_SRC emacs-lisp
      (req-package nyan-mode
               :init
               (progn
                 (nyan-mode)
                 (setq nyan-wavy-trail t))
               :config (nyan-start-animation))
    #+END_SRC

*** =smart-mode-line=
    #+BEGIN_SRC emacs-lisp
      (req-package smart-mode-line
                   :require nyan-mode
                   :init (sml/setup))
    #+END_SRC


*** =powerline=
    #+BEGIN_SRC emacs-lisp :tangle no
      (req-package powerline)
    #+END_SRC

** Faces
   #+BEGIN_SRC emacs-lisp
     (cond
      ((string-equal system-type "windows-nt")
       (req-package unicode-fonts
         :config
         (unicode-fonts-setup))))
     (add-to-list 'default-frame-alist '(font . "NanumGothicCoding-11"))
     (add-to-list 'default-frame-alist '(line-spacing . 2))
     (when (not (eq system-type 'cygwin))
       (set-fontset-font "fontset-default" '(#x1100 . #xffdc) '("나눔고딕코딩" . "unicode-bmp")))
     (set-language-environment '"Korean")
     (prefer-coding-system 'utf-8)
     (setq font-lock-comment-face 'italic)
     (set-face-foreground 'italic "gray50")
     (set-face-attribute 'region nil :background "#aaff90")

     ; (font-family-list)C-j on *scratch* to list
     (setq my-buffer-face-font-family '(:family "Latin Modern Mono"))
     (defun my-buffer-face-mode ()
        "Sets preconfigured font in current buffer"
        (interactive)
        (setq buffer-face-mode-face my-buffer-face-font-family)
        (buffer-face-mode))
     (define-key global-map (kbd "<f12>") 'my-buffer-face-mode)
     ;(set-face-attribute 'default t :font "Latin Modern Mono")
     (if (string-equal system-type "darwin")
         (set-frame-font "AppleMyungjo" nil t)
         (set-frame-font "Latin Modern Mono" nil t))
   #+END_SRC

** Cleanup
   Who wants all that toolbars and scrollbars noise?

   #+BEGIN_SRC emacs-lisp
     (req-package scroll-bar
                  :config
                  (scroll-bar-mode -1))

     (req-package tool-bar
                  :config
                  (tool-bar-mode -1))

     (req-package menu-bar
                  :config
                  (menu-bar-mode -1))

     (setq scroll-step 1)
   #+END_SRC

   I also use [[http://www.emacswiki.org/emacs/DiminishedModes][diminish]] to clean up the modeline.

   #+BEGIN_SRC emacs-lisp
     (req-package diminish)

     (req-package server
                  :diminish (server-buffer-clients . ""))
   #+END_SRC

** Anzu
   This is helpful when searching a string that appears many times in the buffer.

   #+BEGIN_SRC emacs-lisp
     (req-package anzu
                  :config
                  (global-anzu-mode +1))
   #+END_SRC

* Languages
** Emacs Lisp
   #+BEGIN_SRC emacs-lisp
     (req-package lisp-mode
       :init
       (add-hook 'emacs-lisp-mode-hook
                 (lambda ()
                   (setq mode-name " ξ "))))
   #+END_SRC

** R
   #+BEGIN_SRC emacs-lisp
     (req-package ess-site
       :ensure ess)
   #+END_SRC

** Javascript
   #+BEGIN_SRC emacs-lisp
     (req-package tern
       :require tern-auto-complete
       :init
       (progn
         (add-hook 'js-mode-hook
                   (lambda ()
                     (tern-mode t))))
       :config
       (progn
         (tern-ac-setup)))

     (req-package tern-auto-complete)
   #+END_SRC

** Clojure
   #+BEGIN_SRC emacs-lisp
     (cond
      ((string-equal system-type "darwin")
       (req-package spinner
        :loader :gnu)))
     (req-package cider)
   #+END_SRC

** Markdown
   #+BEGIN_SRC emacs-lisp
     (req-package markdown-mode)
   #+END_SRC

** Python
   #+BEGIN_SRC emacs-lisp
     (when (executable-find "python")
       (setq python-shell-interpreter "python3"))
   #+END_SRC

** Octave
   #+BEGIN_SRC emacs-lisp
     (req-package octave-mode
     :init
     (add-to-list 'auto-mode-alist '("\\.m\\'" . octave-mode)))

     (defun my-octave-mode-hook ()
     (define-key octave-mode-map (kbd "M-s M-l") 'octave-send-line)
     (define-key octave-mode-map (kbd "M-s M-b") 'octave-send-block)
     (define-key octave-mode-map (kbd "M-s M-f") 'octave-send-defun)
     (define-key octave-mode-map (kbd "M-s M-a") 'octave-send-buffer)
     (define-key octave-mode-map (kbd "M-s M-r") 'octave-send-region))
     (add-hook 'octave-mode-hook 'my-octave-mode-hook)
   #+END_SRC

** PlantUML
   #+BEGIN_SRC emacs-lisp
   (req-package plantuml-mode
   :init
   (add-to-list 'auto-mode-alist '("\\.plantuml\\'" . plantuml-mode)))
   #+END_SRC

* IDE
  A few conveniences that I like to have in all my =prog-mode= buffers.

** Semantic
   #+BEGIN_SRC emacs-lisp
   (req-package semantic
   :config
   (define-key global-map (kbd "C-c i j") 'semantic-ia-fast-jump)
   (define-key global-map (kbd "C-c i m") 'semantic-ia-complete-symbol-menu))
   #+END_SRC

** Flycheck
   Flycheck has helped me write more programs than I'm totally
   comfortable admitting.

   #+BEGIN_SRC emacs-lisp
     (req-package flycheck
       :diminish (global-flycheck-mode . " ✓ ")
       :config
       (add-hook 'prog-mode-hook 'flycheck-mode)
       (define-key flycheck-mode-map (kbd "C-c f l") #'flycheck-list-errors)
       (define-key flycheck-mode-map (kbd "C-c f p") #'flycheck-previous-error)
       (define-key flycheck-mode-map (kbd "C-c f n") #'flycheck-next-error))

     (req-package helm-flycheck
       :require flycheck
       :commands helm-flycheck
       :config
       (bind-key "C-c ! h"
                 'helm-flycheck
                 flycheck-mode-map))
   #+END_SRC

** Magit
   The only git wrapper that matters.

   #+BEGIN_SRC emacs-lisp
     (req-package magit
       :diminish magit-auto-revert-mode
       :config
       (define-key global-map (kbd "C-x v s") 'magit-status)
       (define-key global-map (kbd "C-x v y") 'magit-show-refs-popup)
       (define-key global-map (kbd "C-x v l") 'magit-log-head))
   #+END_SRC

** Delimiters
   I like my delimiters matched and visually distinct. I used [[https://bitbucket.org/kovisoft/paredit][paredit]] for a
   long time, but I'm currently experimenting with [[https://github.com/Fuco1/smartparens][smartparens]]. As for the
   visual element, I quite like [[https://github.com/jlr/rainbow-delimiters][rainbow-delimiters]].

   #+BEGIN_SRC emacs-lisp
     (req-package smartparens-config
       :ensure smartparens
       :diminish (smartparens-mode . "()")
       :init (smartparens-global-mode t))

     (req-package rainbow-delimiters
       :config
       (add-hook 'prog-mode-hook 'rainbow-delimiters-mode))
   #+END_SRC

** Colors
   I've had to work with colors in a fair bit of code, so having them displayed
   in buffer is convenient.

   #+BEGIN_SRC emacs-lisp
     (req-package rainbow-mode
       :diminish (rainbow-mode . "")
       :config (add-hook 'prog-mode-hook 'rainbow-mode))
   #+END_SRC

   There's also an interesting mode for uniquely coloring identifiers in code
   so that they are easy to scan for. It's still a bit iffy, but it's fun to
   try.

   #+BEGIN_SRC emacs-lisp
     (req-package color-identifiers-mode
       :diminish (color-identifiers-mode . "")
       :init
       (setq color-identifiers:num-colors 50)
       :config
       (progn
         (add-hook 'emacs-lisp-mode-hook 'color-identifiers-mode)
         (add-hook 'ruby-mode-hook 'color-identifiers-mode)))
   #+END_SRC

** Completion
   #+BEGIN_SRC emacs-lisp
     (req-package auto-complete-config
       :ensure auto-complete
       :init
       (progn
         (ac-config-default)
         (setq ac-auto-start 3)))
   #+END_SRC

** Grepping
   Except really I'm =ag=ging.
   #+BEGIN_SRC emacs-lisp
     (req-package helm-ag
       :require evil-leader)
   #+END_SRC

* Annoyances
  Fixing a couple of gripes I have with Emacs.

** Exec path
   #+BEGIN_SRC emacs-lisp
     (req-package exec-path-from-shell
       :init
       (when
           (or
            (not (eq system-type 'windows-nt))
            (memq window-system '(mac ns)))
       (setq exec-path-from-shell-check-startup-files nil)
       (setq exec-path-from-shell-variables '("PATH"))
       (exec-path-from-shell-initialize)))
   #+END_SRC

** Backups and Autosave Files
   These things end up everywhere, so let's stick them all in a temporary
   directory.

   #+BEGIN_SRC emacs-lisp
     (req-package files
       :init
       (progn
         (setq backup-directory-alist
               `((".*" . ,temporary-file-directory)))
         (setq auto-save-file-name-transforms
               `((".*" ,temporary-file-directory t)))))
   #+END_SRC

** Questions
   Keep it short.

   #+BEGIN_SRC emacs-lisp
     (defalias 'yes-or-no-p 'y-or-n-p)
   #+END_SRC

** Clipboard
   #+BEGIN_SRC emacs-lisp
     (setq x-select-enable-clipboard t)
     (setq interprogram-paste-function 'x-selection-value)
   #+END_SRC

** Whitespace
   #+BEGIN_SRC emacs-lisp
    (add-hook 'c-mode-common-hook
        (lambda () (add-to-list 'local-write-file-hooks 'delete-trailing-whitespace)))
    (add-hook 'c-mode-hook
        (lambda () (add-to-list 'local-write-file-hooks 'delete-trailing-whitespace)))
    (add-hook 'c++-mode-hook
        (lambda () (add-to-list 'local-write-file-hooks 'delete-trailing-whitespace)))
   #+END_SRC
** Keyboard Issue in Windows
   #+BEGIN_SRC emacs-lisp
     (cond
      ((string-equal system-type "windows-nt")
	  (global-set-key [C-kanji] 'set-mark-command)))
   #+END_SRC

* Others
  A lot of conveniences collected by David Jung.

** startup
   #+BEGIN_SRC emacs-lisp
     (setq inhibit-startup-message t)

   #+END_SRC
** jm-ndic
   #+BEGIN_SRC emacs-lisp
     (defun jm-ndic (word)
       "search WORD in endic.naver.com"
       (interactive
        (list (let* ((wd (current-word))
                     (word (read-string
                            (format "Dict what (default `%s'): " wd))))
                (if (string= "" word) wd word))))
       (browse-url (concat "http://endic.naver.com/popManager.nhn?sLn=kr&m=search&searchOption=&query=" word)))

     (define-key global-map [(control x) (j)] 'jm-ndic)
   #+END_SRC

** ibuffer
   #+BEGIN_SRC emacs-lisp
     (setq ibuffer-saved-filter-groups
      '(("default"
         ("Dired" (mode . dired-mode))
         ("TODO" (filename . "todo\.org"))
         ("Notes" (or
                   (mode . org-mode)
                   (filename . ".*\.org")))
         ("Programming" (or
                         (mode . c-mode)
                         (mode . c++-mode)
                         (mode . python-mode)
                         (mode . shell-script-mode)
                         (mode . sh-mode)))
         ("Emacs" (or
                   (name . "^\\*scratch\\*$")
                   (name . "^\\*Messages\\*$")
                   (name . "^\\*Warning\\*$")
                   (name . "^\\*eshell\\*$")
                   (mode . Custom-mode)))
         ("Help" (or
                  (mode . Man-mode)
                  (mode . Info-mode)
                  (mode . Help-mode)
                  (mode . help-mode)
                  (name . "^\\*Help*\\*$")))
         ("Version Control" (or
                             (mode . magit-status-mode)
                             (mode . magit-diff-mode)
                             (mode . magit-refs-mode)
                             (mode . magit-revision-mode)
                             (mode . magit-log-mode)
                             (mode . magit-process-mode)
                             (mode . magit-stash-mode))))))
     (setq ibuffer-expert t)
     (add-hook 'ibuffer-mode-hook
               (lambda ()
                 (ibuffer-auto-mode 1)
                 (ibuffer-switch-to-saved-filter-groups "default")))
     (eval-after-load "ibuffer"
       '(define-key ibuffer-mode-map (kbd "* f") 'ibuffer-mark-by-file-name-regexp))
   #+END_SRC

** evil
   #+BEGIN_SRC emacs-lisp
     (define-key global-map [(f11)] 'evil-mode)
   #+END_SRC
** company
   #+BEGIN_SRC emacs-lisp
     (req-package company
       (defun my-company-mode-hook ()
         (company-mode t)
         (define-key company-mode-map [backtab] 'company-complete))
       (add-hook 'prog-mode-hook 'my-company-mode-hook)
       (add-hook 'eshell-mode-hook 'my-company-mode-hook))
   #+END_SRC
** redo
   #+BEGIN_SRC emacs-lisp
     (req-package redo+
       (global-set-key [(control .)] 'redo))
   #+END_SRC
** insert-date
   #+BEGIN_SRC emacs-lisp
     (defun insert-date ()
       "Insert date at point."
       (interactive)
       (insert (format-time-string "%Y-%m-%d %a %p %l:%M")))
   #+END_SRC
** TAGS creating
   #+BEGIN_SRC emacs-lisp
     (defvar c-files-regex ".*\\.\\(c\\|cpp\\|h\\|hpp\\)"
       "A regular expression to match any c/c++ related files under a directory")
     (defun my-semantic-parse-dir (root regex)
       "
        This function is an attempt of mine to force semantic to
        parse all source files under a root directory. Arguments:
        -- root: The full path to the root directory
        -- regex: A regular expression against which to match all files in the directory
       "
       (let (
             ;;make sure that root has a trailing slash and is a dir
             (root (file-name-as-directory root))
             (files (directory-files root t ))
            )
         ;; remove current dir and parent dir from list
         (setq files (delete (format "%s." root) files))
         (setq files (delete (format "%s.." root) files))
         ;; remove any known version control directories
         (setq files (delete (format "%s.git" root) files))
         (setq files (delete (format "%s.hg" root) files))
         (while files
           (setq file (pop files))
           (if (not(file-accessible-directory-p file))
               ;;if it's a file that matches the regex we seek
               (progn (when (string-match-p regex file)
                        (save-excursion
                          (semanticdb-file-table-object file))
                ))
               ;;else if it's a directory
               (my-semantic-parse-dir file regex)
           )
          )
       )
     )

     (defun my-semantic-parse-current-dir (regex)
       "
        Parses all files under the current directory matching regex
       "
       (my-semantic-parse-dir (file-name-directory(buffer-file-name)) regex)
     )

     (defun create-tags-curdir ()
       "
        Parses all the c/c++ related files under the current directory
        and inputs their data into semantic
       "
       (interactive)
       (my-semantic-parse-current-dir c-files-regex)
     )

     (defun create-tags (dir)
       "Prompts the user for a directory and parses all c/c++ related files
        under the directory
       "
       (interactive (list (read-directory-name "Provide the directory to search in:")))
       (my-semantic-parse-dir (expand-file-name dir) c-files-regex)
     )
   #+END_SRC

** Dired Enhancements
   #+BEGIN_SRC emacs-lisp
     (eval-after-load "dired"
       '(progn
          (defadvice dired-advertised-find-file (around dired-subst-directory activate)
            "Replace current buffer if file is a directory."
            (interactive)
            (let* ((orig (current-buffer))
                   ;; (filename (dired-get-filename))
                   (filename (dired-get-filename t t))
                   (bye-p (file-directory-p filename)))
              ad-do-it
              (when (and bye-p (not (string-match "[/\\\\]\\.$" filename)))
                (kill-buffer orig))))))

     (defun mydired-sort ()
       "Sort dired listings with directories first."
       (save-excursion
         (let (buffer-read-only)
           (forward-line 2) ;; beyond dir. header
           (sort-regexp-fields t "^.*$" "[ ]*." (point) (point-max)))
         (set-buffer-modified-p nil)))

     (defadvice dired-readin
       (after dired-after-updating-hook first () activate)
       "Sort dired listings with directories first before adding marks."
       (mydired-sort))

     (add-hook 'dired-mode-hook
               (function (lambda ()
     		      (load "dired-x")
                           ;; Set dired-x buffer-local variables here.  For example:
                           (setq dired-omit-files-p t)
     		      (setq dired-omit-files "^\\.?#\\|^\\.$\\|^\\.\\.$\\|^\\..+$")
     		      (setq dired-omit-extensions '("~"))
                           )))

     (defun my-dired-mode-hook ()
       (define-key dired-mode-map [backspace] 'dired-up-directory))
     (add-hook 'dired-mode-hook 'my-dired-mode-hook)
   #+END_SRC
** CEDET
   #+BEGIN_SRC emacs-lisp
     (req-package cedet)
   #+END_SRC
** EAssist
   #+BEGIN_SRC emacs-lisp
     (req-package eassist
       (global-set-key [(meta return)] 'semantic-complete-analyze-inline)
       (global-ede-mode 1)
       (defun my-c-mode-common-hook ()
         (define-key c-mode-base-map (kbd "M-o") 'eassist-switch-h-cpp)
         (define-key c-mode-base-map (kbd "M-m") 'helm-semantic-or-imenu))
       (add-hook 'c-mode-common-hook 'my-c-mode-common-hook)
       (defun my-python-mode-hook ()
         (define-key python-mode-map (kbd "M-m") 'helm-semantic-or-imenu))
       (add-hook 'python-mode-hook 'my-python-mode-hook)
       (define-key lisp-mode-shared-map (kbd "M-m") 'helm-semantic-or-imenu))
   #+END_SRC
** Hide Show
   #+BEGIN_SRC emacs-lisp
     (add-hook 'c-mode-common-hook
               (lambda()
                 (hs-minor-mode t)
                 (local-set-key (kbd "C-c u") 'hs-toggle-hiding)
                 (local-set-key (kbd "C-c <down>") 'hs-hide-all)
                 (local-set-key (kbd "C-c <up>") 'hs-show-all)))
   #+END_SRC
** Ido
;   #+BEGIN_SRC emacs-lisp
;     (req-package ido-vertical-mode
;       (ido-mode t)
;       (setq ido-vertical-define-keys 'C-n-and-C-p-only)
;       (setq ido-vertical-show-count t)
;       (setq ido-use-faces t)
;       (set-face-attribute 'ido-vertical-first-match-face nil
;                           :background nil
;                           :foreground "orange")
;       (set-face-attribute 'ido-vertical-only-match-face nil
;                           :background nil
;                           :foreground nil)
;       (set-face-attribute 'ido-vertical-match-face nil
;                           :foreground nil)
;       (ido-vertical-mode t))
;   #+END_SRC
** c-highlight
   #+BEGIN_SRC emacs-lisp
     (defun cpp-highlight-if-0/1 ()
       "Modify the face of text in between #if 0 ... #endif."
       (interactive)
       (setq cpp-known-face 'default)
       (setq cpp-unknown-face 'default)
       (setq cpp-face-type 'dark)
       (setq cpp-known-writable 't)
       (setq cpp-unknown-writable 't)
       (setq cpp-edit-list
             '((#("1" 0 1
                  (fontified nil))
                nil
                (foreground-color . "dim gray")
                both nil)
               (#("0" 0 1
                  (fontified nil))
                (foreground-color . "dim gray")
                nil
                both nil)))
       (cpp-highlight-buffer t))
     (defun jpk/c-mode-hook ()
       (cpp-highlight-if-0/1)
       (add-hook 'after-save-hook 'cpp-highlight-if-0/1 'append 'local))
     (add-hook 'c-mode-common-hook 'jpk/c-mode-hook)
   #+END_SRC
** Easier Transition between Windows
   #+BEGIN_SRC emacs-lisp
     ;  M-up, M-down, M-left, and M-right keys.
     (windmove-default-keybindings 'meta)

     ;; Spawning Window
     (fset 'spawn-window-right
           (lambda (&optional arg) "Keyboard macro." (interactive "p") (kmacro-exec-ring-item (quote ([24 49 24 51 M-left] 0 "%d")) arg)))
     (fset 'spawn-window-left
           (lambda (&optional arg) "Keyboard macro." (interactive "p") (kmacro-exec-ring-item (quote ([24 49 24 51 M-right] 0 "%d")) arg)))
     (fset 'spawn-window-down
           (lambda (&optional arg) "Keyboard macro." (interactive "p") (kmacro-exec-ring-item (quote ([24 49 24 50 M-down] 0 "%d")) arg)))
     (fset 'spawn-window-up
           (lambda (&optional arg) "Keyboard macro." (interactive "p") (kmacro-exec-ring-item (quote ([24 49 24 50 M-up] 0 "%d")) arg)))
     (define-key global-map [(control right)]  'spawn-window-left)
     (define-key global-map [(control left)]  'spawn-window-right)
     (define-key global-map [(control down)]  'spawn-window-down)
     (define-key global-map [(control up)]  'spawn-window-up)
   #+END_SRC
** My Swiss army Knife
#+BEGIN_SRC emacs-lisp
    (setq notes-root-path "~/my_Swiss_army_Knife/")
    (defun notes ()
        "Switch to my notes dir."
        (interactive)
        (find-file notes-root-path))
    (defun inbox ()
        "Show my own inbox."
        (interactive)
        (find-file (concat notes-root-path "inbox.org")))
    (defun voca ()
        "Show my vocabulary tables."
        (interactive)
        (find-file (concat notes-root-path "study/voca.org")))
#+END_SRC
** Nuts and Bolts for CB Projects
#+BEGIN_SRC emacs-lisp
   (org-babel-load-file (concat notes-root-path "development/cb_internal_functions.org"))
#+END_SRC
** hook adjustment
   #+BEGIN_SRC emacs-lisp
     (setq dired-mode-hook (remove 'drupal-mode-bootstrap dired-mode-hook))
   #+END_SRC
** Last History
   #+BEGIN_SRC emacs-lisp
     (define-key global-map [(control x)(control r)]  'recentf-open-files)
   #+END_SRC
** eshell
   #+BEGIN_SRC emacs-lisp
    (add-hook 'eshell-mode-hook
        '(lambda () (define-key eshell-mode-map (kbd "C-c C-l") 'helm-eshell-history)))
    (add-hook 'eshell-mode-hook
        '(lambda () (setenv "TERM" "xterm-256color")))
   #+END_SRC
** tdd
   Turn on/off the mode manually because it runs recompile automatically after saving any buffer
   no matters it's prog-mode or not.
   #+BEGIN_SRC emacs-lisp
   (req-package tdd)
   #+END_SRC

** anything
   #+BEGIN_SRC emacs-lisp
     (req-package anything)
     (req-package anything-config
       :config
       (define-key global-map (kbd "M-+") 'anything))
   #+END_SRC

** Communicate with Chrome
   #+BEGIN_SRC emacs-lisp
   (req-package edit-server
   :init
   (edit-server-start))
   #+END_SRC
** Publishing the live buffer
   [[http://stackoverflow.com/questions/36183071/how-can-i-real-time-preview-markdown-in-emacs]]
   1) M-x httpd-start
   2) M-x impatient-mode
   3) localhost:8080/imp

   #+BEGIN_SRC emacs-lisp
   (req-package simple-httpd)
   (req-package impatient-mode
     :init
     (defun markdown-html (buffer)
       (princ (with-current-buffer buffer
       (format "<!DOCTYPE html><html><title>Impatient Markdown</title><xmp theme=\"united\" style=\"display:none;\"> %s  </xmp><script src=\"http://strapdownjs.com/v/0.2/strapdown.js\"></script></html>" (buffer-substring-no-properties (point-min) (point-max))))
       (current-buffer))))
   #+END_SRC

   4) M-x imp-set-user-filter RET markdown-html RET
   5) go back to browser

* Fulfill Requirements
  At long last we need only call the following function to send =req-package= on
  its merry way.

  #+BEGIN_SRC emacs-lisp
    (req-package-finish)
  #+END_SRC
